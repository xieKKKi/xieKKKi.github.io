<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于欧拉-拉格朗日方程的机器人动力学模型</title>
    <url>/2021/01/13/%E5%9F%BA%E4%BA%8E%E6%AC%A7%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="摘要">摘要</h3>
<p>如题。</p>
<span id="more"></span>
<p>（转自我的CSDN博客）</p>
<h2 id="机器人动力学方程">机器人动力学方程</h2>
<p>机器人动力学方程是描述机器人力和运动之间的关系的方程。只描述力和运动的关系，不考虑产生运动的力和扭矩。</p>
<h3 id="欧拉---拉格朗日方程">欧拉 - 拉格朗日方程</h3>
<p>欧拉-拉格朗日方程（OL）描述了处于完整约束下，并且约束力满足虚功原理的机械系统的<strong>力和运动随时间的变化</strong>。</p>
<p>有两种推导方法，先介绍使用牛顿第二定律的推导方法。</p>
<p>根据牛顿第二定律，某质点的运动方程是： <span class="math display">\[
m\ddot y = f-mg
\]</span> 先对时间求导，再对<span class="math inline">\(\dot y\)</span>求偏导，方程左侧可以写为： <span class="math display">\[
m \ddot y = {d \over dt}(m \dot y)={d \over dt}{\partial \over \partial \dot y}({1 \over 2}m \dot y^2)={d \over dt}{\partial K \over \partial \dot y}
\]</span> 其中<span class="math inline">\(K = {1 \over 2}m \dot y^2\)</span>，是动能。</p>
<p>接着将重力表示为： <span class="math display">\[
mg = {\partial \over \partial y}(mgy) = {\partial P \over \partial y}
\]</span> 其中<span class="math inline">\(P = mgy\)</span>表示重力势能。</p>
<p>定义拉格朗日算子<span class="math inline">\(L\)</span>，表示系统动能与势能之差： <span class="math display">\[
L = K-P ={1 \over 2}m \dot y^2-mgy
\]</span> 并且有： <span class="math display">\[
{\partial L\over \partial \dot y} = {\partial K \over \partial \dot y},{\partial L \over \partial y} =-{\partial P \over \partial y}
\]</span></p>
<p>则初始的质点运动方程可化为： <span class="math display">\[
{d \over dt}{\partial K \over \partial \dot y} = f-{\partial P \over \partial y}
\]</span> 即： <span class="math display">\[
{d \over dt}{\partial L \over \partial \dot y}-{\partial L \over \partial y} = f
\]</span> 此方程被称为欧拉-拉格朗日方程。</p>
<p>推广到n自由度的系统，得到： <span class="math display">\[
{d \over dt}{\partial L \over \partial \dot q_k}-{\partial L \over \partial q_k} = \tau_k
\]</span> 其中<span class="math inline">\(\tau_k\)</span>是与广义坐标<span class="math inline">\(q_k\)</span>相关的力。</p>
<h3 id="动能与势能">动能与势能</h3>
<p>欧拉-拉格朗日方程可以直接用来推导动力学方程，前提是我们能够以一组广义坐标来表示该系统的动能和势能。如果要让这能够得到实际应用，那么我们就必须能够针对一个n连杆机器人计算出他的动能和势能。接下来将推到刚性连杆机器人动能和势能的表达式。</p>
<h4 id="动能表示">动能表示</h4>
<p>刚体的动能可表示为平移动能和关于质心的旋转动能之和： <span class="math display">\[
K = {1 \over 2}mv^Tv+{1\over 2}\omega^T Z\omega
\]</span> <span class="math inline">\(Z\)</span>表示物体的惯性张量，是一个3*3的对称矩阵。</p>
<p><span class="math inline">\(Z = RIR^T\)</span>，R是附体坐标系与惯性坐标系之间的姿态变换。</p>
<p><span class="math inline">\(I\)</span>是附体坐标系中的惯性张量，仅取决于物体的形状和质量分布，与物体运动无关。 <img src="https://img-blog.csdnimg.cn/20210113172549829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>速度<span class="math inline">\(v\)</span>和角速度<span class="math inline">\(\omega\)</span>需要转置，因为要考虑多个维度的方向。连杆上任意一点的现速度和角速度可通过雅可比矩阵和关节速度（关节变量的导数）来表示： <span class="math display">\[
v_i = J_{v_i}q\dot q \\
\omega_i = J_{\omega_i}q\dot q
\]</span></p>
<p>机器人总动能可表示为： <span class="math display">\[
K = {1 \over 2}\dot q^T \sum_{i=1}^n[m_i\ {(J_{v_i}(q))}^T \ J_{v_i}(q) \ + \ (J_{\omega_i}(q))^T \ R_{i}(q) \ I_i \ (R_i(q))^T \ J_{\omega_i}(q)]\dot q
\]</span> 用<span class="math inline">\(D(q)\)</span>来表示机器人的惯性矩阵： <span class="math display">\[
D(q) \ = \ \sum_{i=1}^n[m_i\ {(J_{v_i}(q))}^T \ J_{v_i}(q) \ + \ (J_{\omega_i}(q))^T \ R_{i}(q) \ I_i \ (R_i(q))^T \ J_{\omega_i}(q)] \\
K = {1 \over 2}\dot q^T D(q)\dot q
\]</span> 机器人惯性矩阵<span class="math inline">\(D(q)\)</span>有如下特点：</p>
<ol type="1">
<li>只与机器人构型有关</li>
<li>对称且正定</li>
<li>动能总是非负的</li>
</ol>
<h4 id="势能表示">势能表示</h4>
<p>在刚体动力学情形下，势能总是来源于重力。假设物体质量集中在质心，计算第<span class="math inline">\(i\)</span>个连杆的势能： <span class="math display">\[
P_i = m_ig^Tr_{ci}
\]</span> <span class="math inline">\(g\)</span>是惯性坐标系中的重力向量，<span class="math inline">\(r_{ci}\)</span>是连杆<span class="math inline">\(i\)</span>的质心坐标。机器人总势能为： <span class="math display">\[
P = \sum_{i=1}^n P_i = \sum_{i=1}^n m_ig^Tr_{ci}
\]</span> 在m、g保持不变的情况下，机器人势能只与广义坐标<span class="math inline">\(r_{ci}\)</span>有关。</p>
<h3 id="运动方程">运动方程</h3>
<p>上面我们得到了如下结果：</p>
<p>系统动能是关于广义速度（坐标微分）的二次函数： <span class="math display">\[
K = {1 \over 2}\dot q^T D(q)\dot q = {1 \over 2}\sum_{i,j}^n d_{i,j}(q) \dot q_i \dot q_j
\]</span> 系统势能是关于广义坐标的函数，且与广义速度无关： <span class="math display">\[
P =  \sum_{i=1}^n m_ig^Tr_{ci}
\]</span> 欧拉-拉格朗日算子为： <span class="math display">\[
L = K-P ={1 \over 2}\sum_{i,j}^n d_{i,j}(q) \dot q_i \dot q_j-P(q)
\]</span> 欧拉-拉格朗日方程为： <span class="math display">\[
{d \over dt}{\partial L \over \partial \dot q_k}-{\partial L \over \partial q_k} = \tau_k
\]</span> 其中： <span class="math display">\[
{\partial L \over \partial \dot q_k}= \sum_jd_{kj}\dot q_j\\
{d \over dt}{\partial L \over \partial \dot q_k} = \sum_jd_{kj}\ddot q_j+\sum_{j}{d \over dt}d_{kj}\dot q_j \\ 
\ \ \ \ \   \ \ \  \  \  \ \ \ \ \ = \sum_jd_{kj}\ddot q_j+\sum_{i,j}{\partial d_{kj}\over \partial q_i}\dot q_i\dot q_j \\
{\partial L \over \partial q_k} = {1 \over 2}\sum_{i,j} {\partial d_{i,j} \over \partial q_k} \dot q_i \dot q_j - {\partial P \over \partial q_k}
\]</span> 因此对于每个<span class="math inline">\(k=1,2,...n\)</span>，欧拉-拉格朗日方程可以写成： <span class="math display">\[
\sum_jd_{kj}\ddot q_j+\sum_{i,j}\{ {\partial d_{kj}\over \partial q_i} -{1\over 2}{\partial d_{i,j} \over \partial q_k}\} \dot q_i\dot q_j - {\partial P \over \partial q_k}= \tau_k
\]</span> 即： <span class="math display">\[
\sum_jd_{kj}\ddot q_j+\sum_{i,j} {1\over 2}\{ {\partial d_{kj}\over \partial q_i} + {\partial d_{kj}\over \partial q_i} -{\partial d_{i,j} \over \partial q_k}\} \dot q_i\dot q_j - {\partial P \over \partial q_k}= \tau_k
\]</span> 定义Christoffel symbol： <span class="math display">\[
c_{ijk} = c_{jik} ={1\over 2}\{ {\partial d_{kj}\over \partial q_i} + {\partial d_{kj}\over \partial q_i} -{\partial d_{i,j} \over \partial q_k} \}
\]</span> 定义广义重力： <span class="math display">\[
g_k = {\partial P \over \partial q_k}
\]</span> 最终得到欧拉-拉格朗日方程： <span class="math display">\[
\sum_jd_{kj}(q)\ddot q_j+\sum_{i,j} c_{ijk}(q) \dot q_i\dot q_j - g_k(q)= \tau_k
\]</span> 方程左侧三项分别为：</p>
<ol type="1">
<li>广义坐标的二阶导数：惯性项</li>
<li>广义坐标一阶导数的二次型：离心力项+哥氏力项</li>
<li>广义位置（0阶导数）重力项</li>
</ol>
<p>方程可简写为： <span class="math display">\[
D(q)\ddot q+C(q,\dot q)\dot q+g(q) = \tau
\]</span></p>
<h3 id="推导平面2关节机器人的动力学模型">推导平面2关节机器人的动力学模型</h3>
<p>现在考虑下图中带有两个转动关节的平面机械臂。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210113172528262.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>要使用刚刚得到的欧拉-拉格朗日方程，就要与关节位置和关节速度相关的三个量：<span class="math inline">\(D(q),C(q,\dot q),g(q)\)</span>。</p>
<p>首先使用雅可比矩阵来计算动能，计算平移速度： <span class="math display">\[
v_{c1} = J_{v_{c1}}\dot q \\
v_{c2} = J_{v_{c2}}\dot q \\
J_{v_{c1}} = \begin{bmatrix}-l_c sin(q_1) &amp; 0 \\ l_{c1}cos(q_1) &amp; 0\\ 0 &amp; 0 \\\end{bmatrix} \\
J_{v_{c2}} = \begin{bmatrix}-l_1sin(q_1)-l_{c2}sin(q_1+q_2) &amp; -l_{c2}sin(q_1+q_2) \\ l_1cos(q_1)+l_{c2}cos(q_1+q_2) &amp; l_{c2}cos(q_1+q_2)\\ 0 &amp; 0 \\\end{bmatrix}
\]</span> 平移部分对应的动能为： <span class="math display">\[
{1\over 2}m_1 v^T_{c1}v_{c1}+{1\over2}m_2v^T_{c2}v_{c2} = {1\over 2}\dot q\{ m_1J^T_{v_{c1}}J_{v_{c1}} +m_2J^T_{v_{c2}}J_{v_{c2}}  \}\dot q
\]</span> 接下来考虑角速度项： <span class="math display">\[
\omega_1 = \dot q_1k \\
\omega_2 = (\dot q_1+ \dot q_2)k
\]</span> 由于<span class="math inline">\(\omega_i\)</span>与每个关节坐标系的z轴对齐，旋转动能可以简单表示为<span class="math inline">\({1\over 2}I_i\omega_i^2\)</span>，其中<span class="math inline">\(I_i\)</span>是转动惯量，它的轴线穿过连杆i的质心且平行于<span class="math inline">\(z_i\)</span>轴。因此，就广义坐标而言，整个系统的旋转动能为： <span class="math display">\[
{1\over 2}\dot q^T \{ I_1 \begin{bmatrix}1 &amp;0 \\ 0&amp;0 \end{bmatrix} + I_2 \begin{bmatrix} 1&amp;1\\1&amp;1 \end{bmatrix}\}\dot q
\]</span> 惯性矩阵： <span class="math display">\[
D(q) = m_1J^T_{v_{c1}}J_{v_{c1}} +m_2J^T_{v_{c2}}J_{v_{c2}} + \begin{bmatrix} I_1+I_2&amp;I_2 \\ I_2&amp;I_2 \end{bmatrix} = \begin{bmatrix} d_{11}&amp;d_{12} \\ d_{21}&amp;d_{22} \end{bmatrix} \\
\]</span> 计算得： <span class="math display">\[
d_{11} =  m_1l_{c1}^2 + m_2(l_1^2+l^2_{c2}+2l_1l_{c2}cos(q_2))+I_1+I_2\\
d_{12} = d_{21} = m_2(l^2_{c2}+l_1l_{c2}cos(q_2))+I_2 \\
d_{22} = m_2l^2_{c2}+I_2
\]</span> 我们已经得到了惯性矩阵，接下来计算Christoffel符号<span class="math inline">\(c_{ijk}\)</span>： <span class="math display">\[
c_{111}= {1 \over 2}{\partial d_{11}\over \partial q_1} = 0 \\
c_{121}= c_{211}= {1 \over 2}{\partial d_{11}\over \partial q_2} = -m_2l_1l_{c2}sin(q_2) = h \\
c_{221}= {\partial d_{12}\over \partial q_2}-{1 \over 2}{\partial d_{11}\over \partial q_1} = h  \\
c_{112}= {\partial d_{21}\over \partial q_1}-{1 \over 2}{\partial d_{11}\over \partial q_2} = -h  \\
c_{122}= c_{212}=  {1 \over 2}{\partial d_{22}\over \partial q_1} = 0\\
c_{222}= {1 \over 2}{\partial d_{22}\over \partial q_2} = 0 \\
\]</span></p>
<p>接下来计算势能，机械臂的势能等于两个连杆势能之和。 <span class="math display">\[
P_1 = m_1gl_{c1}sin(q_1) \\
P_2 = m_2g(l_{2}sin(q_1)+l_{c2}sin(q_1+q_2))\\
P = P_1+P_2 =(m_1l_{c1}+m_2l_1)gsin(q_1)+m_2l_{c2}gsin(q_1+q_2)
\]</span> 之前的广义重力<span class="math inline">\(g_k\)</span>可变为： <span class="math display">\[
g_1 = {\partial P \over\partial q_1 } = (m_1l_{c1}+m_2l_1)gcos(q_1)+m_2l_{c2}gcos(q_1+q_2)  \\
g_2 = {\partial P \over\partial q_2 } = m_2l_{c2}gcos(q_1+q_2)
\]</span> 最后可以写出系统的动力学方程： <span class="math display">\[
d_{11}\ddot q_1+d_{12} \ddot q_2+c_{121}\dot q_1 \dot q_2 + c_{211}\dot q_2 \dot q_1 +c_{221}\dot q_2^2+g_1=\tau_1 \\
d_{21} \ddot q_1+d_{22}\ddot q_2+c_{112}\dot q_1^2+g_2 = \tau_2
\]</span> 在这种情况下，原方程矩阵<span class="math inline">\(C(q, \dot q)\)</span>由下式给出： <span class="math display">\[
C = \begin{bmatrix}h\dot q_2 &amp; h \dot q_2+h\dot q_1 \\
-h\dot q_1 &amp; 0\end{bmatrix}
\]</span></p>
]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>机器人学</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始搭建个人网站</title>
    <url>/2021/04/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>闲来无事就想着搭一个个人网站来玩玩。这里记录了我整个网站的搭建过程，可供参考。</p>
<span id="more"></span>
<h3 id="安装nodejs">安装nodejs</h3>
<p>前往nodejs官网https://nodejs.org/en/ 下载nodejs长期支持版。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423142344382.png" alt="image-20210423142344382" /><figcaption aria-hidden="true">image-20210423142344382</figcaption>
</figure>
<p>一路默认安装即可。安装完成后得到nodejs和npm两个工具。</p>
<p>按win键，输入cmd，以管理员身份运行。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423143740092.png" alt="image-20210423143740092" /><figcaption aria-hidden="true">image-20210423143740092</figcaption>
</figure>
<p>分别输入</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>可以看到刚刚安装的软件版本。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423143927022.png" alt="image-20210423143927022" /><figcaption aria-hidden="true">image-20210423143927022</figcaption>
</figure>
<h3 id="安装cnpm">安装cnpm</h3>
<p>利用npm安装cnpm淘宝镜像源：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="regexp">//</span>registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423144628884.png" alt="image-20210423144628884" /><figcaption aria-hidden="true">image-20210423144628884</figcaption>
</figure>
<p>安装完成后输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cnpm -v</span></span><br></pre></td></tr></table></figure>
<p>会显示cnpm信息。</p>
<p>接下来使用cnpm安装hexo：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<p>安装完成后输入：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo -v</span></span><br></pre></td></tr></table></figure>
<p>可以看到hexo版本信息 。</p>
<h3 id="安装git">安装git</h3>
<p>从git官网下载一个git安装包，官网下载地址 http://www.git-scm.com/download/</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423150542235.png" alt="image-20210423150542235" /><figcaption aria-hidden="true">image-20210423150542235</figcaption>
</figure>
<p>一路默认安装即可。</p>
<p>之后在系统环境变量中添加：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">C:<span class="symbol">\P</span>rogram Files<span class="symbol">\G</span>it<span class="symbol">\c</span>md</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423151040119.png" alt="image-20210423151040119" /><figcaption aria-hidden="true">image-20210423151040119</figcaption>
</figure>
<p>完成后重启进入命令行，输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span></span><br></pre></td></tr></table></figure>
<p>出现一下内容说明安装成功：</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423151918508.png" alt="image-20210423151918508" /><figcaption aria-hidden="true">image-20210423151918508</figcaption>
</figure>
<h3 id="使用hexo来搭建网站">使用hexo来搭建网站</h3>
<p>在你喜欢的位置新建一个空文件夹，然后在命令行里进入该文件夹（使用cd命令更改命令行目录，不会的可以百度一下）。例如我的空文件夹是Blog。注意该命令行仍然需要管理员权限。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423145530310.png" alt="image-20210423145530310" /><figcaption aria-hidden="true">image-20210423145530310</figcaption>
</figure>
<p>初始化：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>初始化完成后可以在当前目录看到一些hexo生成的博客基础框架文件。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423152145712.png" alt="image-20210423152145712" /><figcaption aria-hidden="true">image-20210423152145712</figcaption>
</figure>
<p>输入：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>
<p>启动博客。输出提示我们到http://localhost:4000这个本地地址访问博客。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423152255670.png" alt="image-20210423152255670" /><figcaption aria-hidden="true">image-20210423152255670</figcaption>
</figure>
<p>在浏览器打开这个地址：</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423152402602.png" alt="image-20210423152402602" /><figcaption aria-hidden="true">image-20210423152402602</figcaption>
</figure>
<p>可以看到hexo已经为我们创建了一篇文章，这是一个简单的教程，可以在本地目录Blog/source/_posts里看到。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423152532109.png" alt="image-20210423152532109" /><figcaption aria-hidden="true">image-20210423152532109</figcaption>
</figure>
<p>如果要新建一篇博文，直接在命令行中输入:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;搭建个人网站教程&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到目录下已经生成了：搭建个人网站教程.md，修改md文件内容即可。</p>
<p>关闭刚刚的网页，ctrl+c在命令行关闭进程。然后依次输入：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure>
<p>重新生成，再输入：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>
<p>再打开网页就可以看到刚刚写的新博客了。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423153738959.png" alt="image-20210423153738959" /><figcaption aria-hidden="true">image-20210423153738959</figcaption>
</figure>
<p>至此本地hexo本地博客已经搭建完成。</p>
<h3 id="将博客部署到github">将博客部署到github</h3>
<p>刚刚得到的博客网站是只能在本地访问的，要能够远程访问，可以将博客部署到github上，这是一个免费的办法。</p>
<p>登录github，新建一个仓库，仓库名称为：你的昵称.github.io。注意这里命名一定要规范，不然后面会出问题。</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423155136301.png" alt="image-20210423155136301" /><figcaption aria-hidden="true">image-20210423155136301</figcaption>
</figure>
<p>新建完成后回到命令行，目录仍然是刚刚的Blog目录。我们接下来要在此目录下安装git的插件。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">cnpm install <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure>
<p>用记事本打开Blog目录下的_config.yml文件，找到最下面type这一行，做如下修改：</p>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423160059850.png" alt="image-20210423160059850" /><figcaption aria-hidden="true">image-20210423160059850</figcaption>
</figure>
<p>repo后面改成你自己刚刚生成的仓库地址。每行前面空两格，冒号是英文，后面有一个空格。保存。</p>
<p>然后输入设置用户名和邮件：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">git</span> <span class="variable">config</span> --<span class="variable">global</span> <span class="variable">user.email</span> <span class="function"><span class="title">xxx</span>(你的邮箱)</span></span><br><span class="line"><span class="variable">git</span> <span class="variable">config</span> --<span class="variable">global</span> <span class="variable">user.name</span> <span class="function"><span class="title">xxx</span>(你的用户名，自定义)</span></span><br></pre></td></tr></table></figure>
<p>部署到远端：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
<p>接着会提示你输入github账号密码。</p>
<p>完成后刷新你的github仓库，可以看到已经更新了。</p>
<p>接着直接访问：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>xiekkki.github.io/</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/xieKKKi/myBlogImages/master/imgs/image-20210423161354803.png" alt="image-20210423161354803" /><figcaption aria-hidden="true">image-20210423161354803</figcaption>
</figure>
<p>大功告成。</p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>独立关节PD控制及其matlab simulink仿真</title>
    <url>/2021/01/14/%E7%8B%AC%E7%AB%8B%E5%85%B3%E8%8A%82PD%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6matlab%20simulink%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<h3 id="摘要">摘要</h3>
<p>如题。</p>
<span id="more"></span>
<p>（转自我的CSDN博客）</p>
<h3 id="原理">原理</h3>
<p>机器人控制常采用PD控制和PID控制，其优点是控制律简单，易于实现，无需建模。</p>
<p>当忽略重力和外力干扰时，采用独立的PD控制，能满足机器人定点控制的要求。</p>
<p>根据欧拉-拉格朗日方程建立n连杆机器人的动力学模型： <span class="math display">\[
D(q)\ddot q+C(q,\dot q)\dot q+g(q)=\tau
\]</span> 其中D代表惯性项，C代表向心力项/哥氏力项，g代表重力项，q代表关节坐标，<span class="math display">\[\tau\]</span>代表了系统广义力。</p>
<p>PID控制基于误差，设固定的期望位置为 <span class="math display">\[ q_d \]</span>，跟踪误差为<span class="math display">\[e=q_d-q\]</span>，由于<span class="math display">\[q_d\]</span>为常数，<span class="math display">\[\dot q_d=\ddot q_d =0\]</span>。</p>
<p>PD控制律为： <span class="math display">\[
\tau = K_d \dot e + K_p e
\]</span> 忽略重力，机器人方程表示为： <span class="math display">\[
D(q)(0 - \ddot q)+C(q,\dot q)(0 -\dot q)=- \tau
\]</span> 进一步化为： <span class="math display">\[
D(q)(\ddot q_d - \ddot q)+C(q,\dot q)(\dot q_d -\dot q)+ K_d \dot e =-K_p e
\]</span></p>
<p>考虑如下二连杆机器人系统：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210114154010661.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>其中：</p>
<p><img src="https://img-blog.csdnimg.cn/20210114154059646.png" /></p>
<p>实例化，假设<span class="math display">\[ p=[2.90{\,} 0.76 {\,}0.87]^T, q_0 =[0 {\,}0]^T, \dot q_0 = [0{\,} 0 ]^T\]</span>,目标位置<span class="math display">\[q_d(0)=[1.0 {\,}1.0]^T\]</span>，取<span class="math display">\[K_p=\begin{bmatrix}100 &amp;0\\0&amp;100 \end{bmatrix}, K_d=\begin{bmatrix}100 &amp;0\\0&amp;100 \end{bmatrix}\]</span>。</p>
<p>得到： <span class="math display">\[
D(q)=\begin{bmatrix}3.66+1.74\cos q_2 &amp;0.76+0.87\cos q_2\\0.76+0.87\cos q_2&amp;0.76 \end{bmatrix}, C(q,\dot q)=\begin{bmatrix}-0.87 \dot q_2\sin q_2 &amp;-0.87(\dot q_1 + \dot q_2)\sin q_2\\0.87 \dot q_1\sin q_2&amp;0 \end{bmatrix}
\]</span> 代入刚刚得到的机器人方程，并选取系统状态变量<span class="math display">\[[θ_1,\dot θ_1 ,θ_2,\dot θ_2] = [q_1,\dot q_1, q_2,\dot q_2]\]</span>： <span class="math display">\[
\begin{cases}
\dot θ_1 = \dot  θ_1 \\
\ddot \theta_1 = {τ_1-(0.76+0.87cosθ_2 ) \ddot θ_2  + 0.87sin(θ_2 )\dot θ_1 \dot θ_2 +0.87(\dot θ_1 +\dot θ_2)sinθ_2 \dot θ_2 \over (3.66+1.74cosθ_2 )} \\
\dot θ_2 =\dot θ_2 \\
\ddot \theta_2 = {τ_2-(0.76+0.87cosθ_2 ) \ddot θ_1 -0.87sinθ_2 (\dot θ_1 )^2 \over 0.76}\\
\tau_1 = K_p(q_{d1}-q_1)-K_d \dot q_1 \\
\tau_2 = K_p(q_{d2}-q_2)-K_d \dot q_2
\end{cases}
\]</span></p>
<h3 id="matlabsimulink-仿真建模">Matlab/simulink 仿真建模</h3>
<p>依据上面得到的式子建立matlab simulink仿真模型：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-r7H7RAFz-1610609990391)(image-20210107132308822.png)]</p>
<p>注意计算<span class="math display">\[\ddot q_1, \ddot q_2\]</span>使用函数模块时候不能选择这个：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210114154137426.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>否则就会报错：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210114154143373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>要选择这个：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210114154152376.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>示波器输出波形为：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210114154202354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>修改Kp，Kd，使得<span class="math display">\[K_p=\begin{bmatrix}1000&amp;0\\0&amp;1000 \end{bmatrix}, K_d=\begin{bmatrix}100 &amp;0\\0&amp;100 \end{bmatrix}\]</span>，得到：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210114154214127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>调节时间缩短，响应变快。</p>
<p>修改Kp，Kd，使得<span class="math display">\[K_p=\begin{bmatrix}100&amp;0\\0&amp;100 \end{bmatrix}, K_d=\begin{bmatrix}10 &amp;0\\0&amp;10 \end{bmatrix}\]</span>，得到：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210114154222903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>出现过多超调，响应时间变长。</p>
<h3 id="加入重力补偿">加入重力补偿</h3>
<p>事实上完全不受外力，没有干扰的机械手系统是不存在的，独立的PD控制只是基础，可以作为参考来对系统进行分析。如果加入重力补偿，PD控制律变为： <span class="math display">\[
\tau = K_d \dot e + K_p e + \hat G(q)
\]</span> 其中<span class="math display">\[\hat G(q)\]</span>表示对重力矩的估计值。</p>
<p>机器人方程为： <span class="math display">\[
D(q)(\ddot q_d - \ddot q)+C(q,\dot q)(\dot q_d -\dot q)+ K_d \dot e + K_p e+\hat G(q)-G(q)=0
\]</span> 对重力矩的估计方法有如下两类：</p>
<ol type="1">
<li>当对重力矩估计准确时候，<span class="math display">\[\hat G(q), G(q)\]</span>抵消，方程退化为上面的独立PD控制。</li>
<li>当对重力矩的估计值不准确时候，需要设计重力补偿算法。目前代表性的重力补偿PD控制算法有在线估计的和固定的重力补偿PD控制。其中在线补偿更为准确，但是会消耗更多的计算资源，固定的补偿特性与之相反。</li>
</ol>
]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>机器人学</tag>
      </tags>
  </entry>
  <entry>
    <title>倒立摆状态反馈控制——分析、建模与仿真(matlab)</title>
    <url>/2020/06/01/%E5%80%92%E7%AB%8B%E6%91%86%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94%E5%88%86%E6%9E%90%E3%80%81%E5%BB%BA%E6%A8%A1%E4%B8%8E%E4%BB%BF%E7%9C%9F(matlab)/</url>
    <content><![CDATA[<h3 id="摘要">摘要</h3>
<p>倒立摆是机器人学中一个非常重要的模型，火箭、导弹、独轮车、双足机器人、四足机器人，基本都是倒立摆的变形。这里是对基本的倒立摆问题的一些研究和思考。</p>
<span id="more"></span>
<p>（转自我的CSDN博客）</p>
<h1 id="倒立摆状态反馈控制">倒立摆状态反馈控制</h1>
<h2 id="问题描述">问题描述</h2>
<p>关于倒立摆的问题描述如下： 如图所示的倒立摆系统。摆的关节连接在一个可移动的小车上，小车由电机驱动，电机水平驱动力为<strong>F</strong>，摆杆质量为<strong>m</strong>，小车质量为<strong>M</strong>，摆长<strong>2l</strong>。 现在要研究外力F如何能使摆保持垂直的位置。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020051815081870.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h2 id="状态空间模型">状态空间模型</h2>
<p>设摆杆偏离垂直位置角度为<strong>θ</strong>，小车位移为<strong>y</strong>。小车对摆水平方向和垂直方向反作用力分别为<strong>H和V</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/202005181519403.png" alt="在这里插入图片描述" /> 根据牛顿定律可以写出摆水平、垂直方向的力平衡方程： <img src="https://img-blog.csdnimg.cn/20200518152031278.png" alt="在这里插入图片描述" /> 记摆杆对其质心的转动惯量为<strong>I</strong>，则摆质心的力矩方程为： <img src="https://img-blog.csdnimg.cn/20200518152526233.png" alt="在这里插入图片描述" /> 用k表示摩擦系数，小车水平方向的力平衡方程为： <img src="https://img-blog.csdnimg.cn/20200518153034256.png" alt="在这里插入图片描述" /> 联立以上四个式子，小曲中间变量V、H，得到： <img src="https://img-blog.csdnimg.cn/20200518153441440.png" alt="在这里插入图片描述" /> 由于θ比较小，这里不妨使sinθ = 0，cosθ = 1，简化方程为： <img src="https://img-blog.csdnimg.cn/20200518153853325.png" alt="在这里插入图片描述" /> 设摆杆质量分布均匀，忽略摩擦（k=0，摩擦力也不会影响能控性），有： <img src="https://img-blog.csdnimg.cn/20200518155051441.png" alt="在这里插入图片描述" /> 定义系统状态： <img src="https://img-blog.csdnimg.cn/20200518155241173.png" alt="在这里插入图片描述" /> 得到状态方程： <img src="https://img-blog.csdnimg.cn/20200518155256854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 即： <img src="https://img-blog.csdnimg.cn/20200518155401489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 计算系统的能控性矩阵： <img src="https://img-blog.csdnimg.cn/2020051815571467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 能控性矩阵的秩为4，所以系统完全能控。</p>
<h2 id="设计状态反馈控制">设计状态反馈控制</h2>
<p>为了方便设计，不妨设<strong>M=2kg，m=0.1kg，l=0.5m</strong>。代入状态方程： <img src="https://img-blog.csdnimg.cn/20200519084128428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 其中： <img src="https://img-blog.csdnimg.cn/20200519084208893.png" alt="在这里插入图片描述" /> 根据<strong>极点配置原理</strong>，线性定常系统通过状态反馈可以任意配置闭环系统极点的充分必要条件是系统完全能控。 系统的能控性在上面已经证明。 于是采用状态反馈，即： <img src="https://img-blog.csdnimg.cn/20200519084338722.png" alt="在这里插入图片描述" /> K为4*1矩阵。 原系统的特征多项式为： <img src="https://img-blog.csdnimg.cn/20200519085132333.png" alt="在这里插入图片描述" /> 存在大于等于0的极点，显然不加控制的系统是不稳定的，倒立摆不能倒立。 所以我们要<strong>配置合适的极点</strong>来使得系统达到稳定性要求。</p>
<p>这是一个四阶系统，可以设计两个远离虚轴的极点，和两个<strong>靠近虚轴的闭环主导极点</strong>，系统的瞬态性能指标主要由主导极点决定。 这样就可以<strong>把一个高阶系统简化成一个二阶系统</strong>。</p>
<p><strong>典型二阶系统传递函数</strong>如下： <img src="https://img-blog.csdnimg.cn/20200519091717626.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20200519091733165.png" alt="在这里插入图片描述" /> <strong>欠阻尼时的两个特征根</strong>为： <img src="https://img-blog.csdnimg.cn/20200519093404130.png" alt="在这里插入图片描述" /> <strong>典型二阶系统的瞬态性能指标</strong>如下：</p>
<p>（1）上升时间： <img src="https://img-blog.csdnimg.cn/20200519092300720.png" alt="在这里插入图片描述" /> 其中 <img src="https://img-blog.csdnimg.cn/20200519092025406.png" alt="在这里插入图片描述" /> （2）峰值时间： <img src="https://img-blog.csdnimg.cn/20200519092322664.png" alt="在这里插入图片描述" /> （3）最大超调量： <img src="https://img-blog.csdnimg.cn/20200519092540201.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20200519092514156.png" alt="在这里插入图片描述" /> 通常取控制系统最大超调量为25% ~ 1.5%，对应的阻尼比为0.4 ~ 0.8 。</p>
<p>（4）调节时间： <img src="https://img-blog.csdnimg.cn/20200519092811560.png" alt="在这里插入图片描述" /> （5）震荡次数 <img src="https://img-blog.csdnimg.cn/20200519092911234.png" alt="在这里插入图片描述" /> 综上，我们想要使系统具有<strong>较短的调节时间和适当的超调量</strong>，可取 <img src="https://img-blog.csdnimg.cn/20200519093604919.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20200519093612456.png" alt="在这里插入图片描述" /> 于是闭环主导极点为： <img src="https://img-blog.csdnimg.cn/20200519093700922.png" alt="在这里插入图片描述" /> 再取两个远离虚轴的极点： <img src="https://img-blog.csdnimg.cn/20200519093722817.png" alt="在这里插入图片描述" /> 期望特征多项式为： <img src="https://img-blog.csdnimg.cn/20200519093800207.png" alt="在这里插入图片描述" /> 已经有了期望的闭环特征多项式，接下来要<strong>如何根据特征多项式确定反馈增益K</strong>呢？ 有两种常见方法： <img src="https://img-blog.csdnimg.cn/20200519094904985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20200519094926393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 其中<strong>算法1在低阶系统中应用会比较方便，但是对于高阶系统，算法2的计算会更为简单</strong>。 本问题是四阶系统，我们选用算法2 。 刚刚我们已经计算过原特征多项式。 <img src="https://img-blog.csdnimg.cn/2020051910172255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 我们已经计算出了反馈增益K。</p>
<p>综上，只需要使得外力输入 <img src="https://img-blog.csdnimg.cn/20200519084338722.png" alt="在这里插入图片描述" /> 即可使倒立摆保持垂直状态。</p>
<h2 id="建立simulink模型">建立simulink模型</h2>
<p>根据A、B、K矩阵画出框图： <img src="https://img-blog.csdnimg.cn/20200628203711312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 给定状态x1（即θ）初值：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200601123006150.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ma4KziYv-1590985727990)(C:-user-images-20200525170331331.png)]" /><figcaption aria-hidden="true">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ma4KziYv-1590985727990)(C:-user-images-20200525170331331.png)]</figcaption>
</figure>
<p>运行仿真，观测四个状态的变化。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200628203647460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>观察x1，可知倒立摆偏离角度在很短时间内收敛到0，控制效果很好。</p>
<h2 id="设计降维状态观测器">设计降维状态观测器</h2>
<p>在以上的状态反馈控制中，我们使用了4个状态变量来进行反馈控制： <img src="https://img-blog.csdnimg.cn/20200519084208893.png" alt="在这里插入图片描述" /> 这就意味着，在实际的应用中，我们需要<strong>同时用传感器测量4个变量</strong>： 摆杆角度、摆杆角速度、小车位移、小车速度。</p>
<p>但是有的时候，我们不想用这么多传感器，或者有的时候，某些状态量的测量并不方便。 <strong>能不能减少反馈的状态个数，同时也能达到控制效果呢</strong>？</p>
<p>可以设计降维观测器配合反馈控制来达到目的。</p>
<p>不过在此之前可能有人会想：摆杆角速度和小车的速度不就分别是角度和位移对时间的微分吗？ 的确如此，但是<strong>直接用微分计算得到的速度与用传感器测得的速度是有不同的。在状态观测器的设计中，用一个状态的微分产生另一个状态的方法通常是不可取的，因为噪声通常比控制信号变化快，信号的微分会使噪声的作用增强，即减小了信噪比。</strong></p>
<p>这里假设摆杆的角度和小车的位移能被测量，即状态</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200601123541235.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>已知，需要设计状态观测器观测其余两个状态。</p>
<p><strong>将状态重新排序</strong>： <span class="math display">\[
x1 = x，x2=y, x3 = \dot θ，x4= \dot y
\]</span> 系统输出为： <span class="math display">\[
y=\begin{bmatrix}
\theta \\
y\\
\end{bmatrix}
\]</span> 状态矩阵变为： <span class="math display">\[
A=\begin{bmatrix}0  &amp; 0&amp;1&amp;0 \\ 0 &amp; 0&amp;0&amp;1\\15.244&amp;0&amp;0&amp;0\\-0.363&amp;0&amp;0&amp;0 \end{bmatrix}
B=\begin{bmatrix}0  \\ 0 \\-0.741\\0.494 \end{bmatrix}
C=\begin{bmatrix}1  &amp; 0&amp;0&amp;0 \\ 0 &amp;1&amp;0&amp;0 \end{bmatrix}
\]</span></p>
<p>降维观测器设计思路：</p>
<p><img src="https://img-blog.csdnimg.cn/20200601123049630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mhKzq5aO-1590985727998)(C:-user-images-20200531233309196.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0acABmru-1590985728000)(C:-user-images-20200531233355203.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cvb2jLCC-1590985728000)(C:-user-images-20200601084105169.png)]" /> <img src="https://img-blog.csdnimg.cn/20200601123107667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20200601123125483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 首先<strong>判断系统的能观性</strong>： <span class="math display">\[
Rank Qc = \begin{bmatrix}C \\ CA\\CA^2\\CA^3 \end{bmatrix}=4
\]</span> 系统完全能观，确保可以设计降维状态观测器来观测状态。</p>
<p>令 <span class="math display">\[
C=\begin{bmatrix}C1 &amp; C2 \end{bmatrix},C1=\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix},C2=\begin{bmatrix}0&amp;0\\0&amp;0\end{bmatrix}
\]</span> C1非奇异，则<strong>状态变换矩阵</strong> <span class="math display">\[
P=\begin{bmatrix}1 &amp; 0&amp;0&amp;0 \\ 0 &amp; 1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1 \end{bmatrix}
\]</span></p>
<p><span class="math display">\[
\overline A=\begin{bmatrix}0  &amp; 0&amp;1&amp;0 \\ 0 &amp; 0&amp;0&amp;1\\15.244&amp;0&amp;0&amp;0\\-0.363&amp;0&amp;0&amp;0 \end{bmatrix}=\begin{bmatrix}\overline A_{11}&amp;\overline A_{12} \\ \overline A_{21}&amp;\overline A_{22}\end{bmatrix},
\overline B=\begin{bmatrix}0  \\ 0 \\-0.741\\0.494 \end{bmatrix}=\begin{bmatrix}\overline B_{1} \\\overline B_{2}\end{bmatrix},
\overline C=\begin{bmatrix}1  &amp; 0&amp;0&amp;0 \\ 0 &amp;1&amp;0&amp;0 \end{bmatrix}
\]</span></p>
<p><strong>设计反馈增益矩阵</strong>:</p>
<p>前面我们在设计状态反馈的时候已经得出了系统的闭环主导极点： <span class="math display">\[
\lambda_1^*=-2+j2\sqrt3,\lambda_2^*=-2-j2\sqrt3
\]</span> 一般设计，观测器极点为系统主导极点3~5倍。</p>
<p>我们先试着使极点为-10，-10。</p>
<p>期望特征方程为： <span class="math display">\[
\lambda^2+20\lambda+100=0
\]</span> 观测器特征方程为： <span class="math display">\[
det(sI-\overline A_{22}+\overline H\overline A_{12})=s^2+(H_{11}+H_{22})s+H_{11}H_{22}-H_{21}H_{22}=0
\]</span></p>
<p>不妨使： <span class="math display">\[
H_{21}=0,H_{22}=0,H_{11}=H_{22}
\]</span> 比较系数，得： <span class="math display">\[
H_{11}=10,H_{22}=10
\]</span> <strong>子系统的观测器为</strong>：</p>
<p><span class="math display">\[
\begin{cases}
\dot z=\begin{bmatrix} -10&amp;0 \\0&amp;-10 \end{bmatrix}\hat x_2+\begin{bmatrix} -0.741 \\0.494 \end{bmatrix}u+\begin{bmatrix}15.244&amp;0 \\-0.363&amp;0\end{bmatrix}y\\
\hat x_2=z+\begin{bmatrix} 10&amp;0\\0&amp;10 \end{bmatrix}y
\end{cases}
\]</span></p>
<p><strong>原系统的状态观测量为</strong>： <span class="math display">\[
\hat x=\begin{bmatrix}y\\\hat x_2\end{bmatrix},y=\begin{bmatrix} x_1\\x_2 \end{bmatrix}=\begin{bmatrix} \theta\\y^{&#39;} \end{bmatrix}
\]</span> 于是我们便构建了x3、x4，即两个不可测量的速度的观测值。</p>
<p>接下来只需要<strong>将观测值代入状态反馈</strong>。</p>
<h2 id="建立simulink模型-1">建立Simulink模型</h2>
<p>根据以上建立仿真模型：</p>
<p><img src="https://img-blog.csdnimg.cn/20200601123233338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 为了简化框图，将原系统模型替换成了直接State space表示的形式，具体设置为：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200601123248486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>可以看到我们给定了倒立摆角度的初值1，其他全部设为0。</p>
<p>运行仿真，角度scope的输出为：</p>
<p><img src="https://img-blog.csdnimg.cn/20200601123300369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 系统可以控制倒立摆达到平衡状态，但是<strong>超调量和调节时间都增大</strong>了。</p>
<p>我们试着<strong>调整观测器极点</strong>，使两极点都为-20：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200601123314527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<figure>
<img src="https://img-blog.csdnimg.cn/20200601123324650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>影响并不是很大。</p>
<p>实际上，当我试着<strong>将原系统框图完整地画出，并比较观测器观测值与实际状态的误差</strong>的时候，发现观测器已经能够很好地跟踪未知状态了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200628204038292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> θ曲线对比</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020060112335195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>速度曲线对比</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200601123400100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>试着在初始状态基础上<strong>加入一个阶跃扰动</strong>，扰动发生时间为1s，幅度设置较大（1000）：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200601123414215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<figure>
<img src="https://img-blog.csdnimg.cn/20200601123423558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzQyNTI1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>观察到，系统受扰后，仍能迅速调整达到稳定。</p>
<h2 id="总结">总结</h2>
<p>综上，倒立摆问题已经基本得到了解决。</p>
<p><strong>只需要通过传感器测量出摆的角度和小车位移，就能设计状态观测器观测出摆的角速度和小车速度，进而通过状态反馈，得到需要输入的外力F。通过此外力F，就能使倒立摆保持平衡。</strong></p>
<p>在实际运用中，根据场景要求，对参数进行优化即可。</p>
<p>matlab模型在我的CSDN个人主页资源中可以找到。</p>
]]></content>
      <categories>
        <category>自控</category>
      </categories>
      <tags>
        <tag>自动控制原理</tag>
        <tag>倒立摆</tag>
      </tags>
  </entry>
</search>
